

--------------------------------------------------------------------------------------
-- GiDEL Copyright © 1993-2013  
-- HDL tile_rdif is generated by GiDEL  ProcWizard Application  version 9.2.1.0
-- tile_rdif is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"C:\Users\Krishna\Desktop\Research\Ex_Emulator\ProceV_2\Emulator.pcaf".
-- This file may only be used for initialization and usage of GiDEL PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Mon Feb 09 21:21:45 2015

-------------------------------------------------------------------------------------


	SUBDESIGN   tile_rdif
	   (
		--============================================
		--=          Local bus connections           =
		--============================================
		clk                        : INPUT;                    -- local bus clock
		clrn                       : INPUT;                    -- Global reset signal. Active low
		blast_o                    : OUTPUT;
		blast                      : INPUT = GND;
		ads                        : INPUT;
		lw_r_i                     : INPUT;
		lw_r                       : OUTPUT;
		wait_l                     : INPUT = VCC;
		bterm                      : OUTPUT;
		ready                      : OUTPUT;
		addr[31..0]                : OUTPUT;                   -- local bus address
		ad_i[255..0]               : INPUT;
		ad_o[255..0]               : OUTPUT;
		ad[255..0]                 : OUTPUT;
		mem_data[255..0]           : INPUT = GND;
		--============================================
		--=       Feadback from user memories        =
		--============================================
		mem_ready                  : INPUT;                    -- assert this signal high when memory data is valid
		term                       : INPUT = VCC;              -- assert this signal high to enable burst mode
		--============================================
		--=  Output from the logic to the host (status registers)  =
		--============================================
		done                       : INPUT;
		-- version of RBF
		rbf_version[7..0]          : INPUT;                    -- RBF_Info[7..0]
		almost_full_dst            : INPUT;                    -- status_dst[1]
		--============================================
		--=  Input from the host to the logic (mode registers)  =
		--============================================
		id2                        : INPUT = GND;
		id1                        : INPUT = GND;
		id0                        : INPUT = VCC;
		--============================================
		--=  Selectors to all memory address spaces  =
		--============================================
		sel_singlea_dst            : OUTPUT;
	  )


VARIABLE

	 
	ad_oe                      : LCELL;
	ready_i                    : NODE;
	sel_gmode                  : SRFF;
	sel_ic, sel_read_ic        : SRFF;
	sel_ic_lcell               : LCELL;
	addr[31..0]                : DFFE;
	ad_out[255..0]             : DFF;
	sel_ports                  : NODE;
	sel_ports_d                : DFF;
	bus_end                    : NODE;
	--============================================
	--=        Address decoder selectors         =
	--============================================
	den                        : SRFF;
	sel_done                   : SRFF;
	sel_RBF_Info               : SRFF;
	sel_status_dst             : SRFF;
	sel_singlea_dst_ff         : SRFF;


BEGIN

	  
	DEFAULTS
		ad_out[]              = GND;
	END DEFAULTS;
	 
	ad_out[].clk    = clk;
	sel_ports_d.clk = clk;
	lw_r	  	  = lw_r_i;
	ad[]		  = ad_i[];
	IF sel_ports THEN
		ad_o[]	= ad_out[];        -- mode registers read back data to local bus
	ELSE
		ad_o[]	= mem_data[];
	END IF;
	ad_oe         = sel_read_ic;
	IF sel_done THEN
		ad_out[0]=done;
	END IF;


	IF sel_RBF_Info THEN
			ad_out[7..0]=rbf_version[7..0];
	END IF;


	IF sel_status_dst THEN
			ad_out[1]=almost_full_dst;
	END IF;


	bus_end  = wait_l & !ready_i & !den & (!blast # !term) # ads & den;
	sel_gmode.clk         = clk;
	sel_gmode.clrn        = clrn;
	sel_gmode.r           = bus_end;
	ready                 = ready_i;
	bterm                 = VCC;
	sel_ic_lcell          = sel_ic;
	sel_ports             = sel_gmode;
	den.clk               = clk;
	den.s                 = bus_end;
	den.r                 = !ads;
	sel_ic.clk            = clk;
	sel_ic.clrn           = clrn;
	sel_ic.r              = bus_end;
	sel_read_ic.clk       = clk;
	sel_read_ic.clrn      = clrn;
	sel_read_ic.r         = bus_end;
	sel_done.clk          = clk;
	sel_done.clrn         = clrn;
	sel_done.r            = bus_end;
	  
	sel_RBF_Info.clk      = clk;
	sel_RBF_Info.clrn     = clrn;
	sel_RBF_Info.r        = bus_end;
	  
	sel_status_dst.clk    = clk;
	sel_status_dst.clrn   = clrn;
	sel_status_dst.r      = bus_end;
	  
	sel_singlea_dst       = sel_singlea_dst_ff & wait_l;
	sel_singlea_dst_ff.clk  = clk;
	sel_singlea_dst_ff.clrn  = clrn;
	sel_singlea_dst_ff.r  = bus_end;
	  
	IF !ads THEN
		addr[]                = ad[31..0];
	ELSE
		addr[]                = addr[] + 32;
	END IF;
	addr[].clk            = clk;
	addr[].ena            = !ads  #  wait_l & !ready_i & !den;
	--============================================
	--=  Selectors to all memory address spaces  =
	--============================================
	  
	  
	sel_ports_d = sel_ports;
	 
	ready_i               = !sel_ic_lcell # !sel_ports_d & sel_read_ic & sel_ports # sel_singlea_dst_ff & !mem_ready;
	  
	 
	



	IF !ads & !ad[31] THEN
		IF (ad[24..24] == 0) THEN
			IF (ad[23..21] == (id2,id1,id0) ) THEN
				sel_ic.s = VCC;
				sel_read_ic.s = !lw_r;
	
				IF !ad[20] THEN
					sel_gmode.s=VCC;
					sel_done.s =  (ad[6..4] == H"3");
					sel_RBF_Info.s =  (ad[6..4] == H"0");
					sel_status_dst.s =  (ad[6..4] == H"4");
	
				ELSE
						-- SRAM / internal memories address space
					sel_singlea_dst_ff.s = VCC &!lw_r;
				END IF;

			END IF;
		END IF;
	END IF;
  END;
