

--------------------------------------------------------------------------------------
-- GiDEL Copyright © 1993-2013  
-- HDL tile_wrif is generated by GiDEL  ProcWizard Application  version 9.2.1.0
-- tile_wrif is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"C:\Users\Krishna\Desktop\Research\Ex_Emulator\ProceV_2\Emulator.pcaf".
-- This file may only be used for initialization and usage of GiDEL PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Mon Feb 09 21:21:45 2015

-------------------------------------------------------------------------------------


	SUBDESIGN   tile_wrif
	   (
		--============================================
		--=          Local bus connections           =
		--============================================
		clk                        : INPUT;                    -- local bus clock
		clrn                       : INPUT;                    -- Global reset signal. Active low
		blast_o                    : OUTPUT;
		blast                      : INPUT = GND;
		ads                        : INPUT;
		lw_r_i                     : INPUT;
		lw_r                       : OUTPUT;
		wait_l                     : INPUT = VCC;
		bterm                      : OUTPUT;
		ready                      : OUTPUT;
		addr[31..0]                : OUTPUT;                   -- local bus address
		ad_i[255..0]               : INPUT;
		ad_o[255..0]               : OUTPUT;
		ad[255..0]                 : OUTPUT;
		mem_data[255..0]           : INPUT = GND;
		--============================================
		--=       Feadback from user memories        =
		--============================================
		mem_ready                  : INPUT;                    -- assert this signal high when memory data is valid
		term                       : INPUT = VCC;              -- assert this signal high to enable burst mode
		--============================================
		--=  Input from the host to the logic (mode registers)  =
		--============================================
		go                         : OUTPUT;
		id2                        : INPUT = GND;
		id1                        : INPUT = GND;
		id0                        : INPUT = VCC;
		--============================================
		--=  Selectors to all memory address spaces  =
		--============================================
		sel_reset_singlea          : OUTPUT;
	  )


VARIABLE

	 
	ad_oe                      : LCELL;
	ready_i                    : NODE;
	sel_gmode                  : SRFF;
	sel_ic, sel_read_ic        : SRFF;
	sel_ic_lcell               : LCELL;
	addr[31..0]                : DFFE;
	ad_out[255..0]             : DFF;
	sel_ports                  : NODE;
	sel_ports_d                : DFF;
	bus_end                    : NODE;
	--============================================
	--=  Fields and registers for writing by user  =
	--============================================
	go                         : DFFE;
	--============================================
	--=        Address decoder selectors         =
	--============================================
	den                        : SRFF;
	sel_go                     : SRFF;
	sel_reset_singlea_ff       : SRFF;


BEGIN

	  
	DEFAULTS
		ad_out[]              = GND;
	END DEFAULTS;
	 
	ad_out[].clk    = clk;
	sel_ports_d.clk = clk;
	lw_r	  	  = lw_r_i;
	ad[]		  = ad_i[];
	IF sel_ports THEN
		ad_o[]	= ad_out[];        -- mode registers read back data to local bus
	ELSE
		ad_o[]	= mem_data[];
	END IF;
	ad_oe         = sel_read_ic;
	bus_end  = wait_l & !ready_i & !den & (!blast # !term) # ads & den;
	sel_gmode.clk         = clk;
	sel_gmode.clrn        = clrn;
	sel_gmode.r           = bus_end;
	ready                 = ready_i;
	bterm                 = VCC;
	sel_ic_lcell          = sel_ic;
	sel_ports             = sel_gmode;
	den.clk               = clk;
	den.s                 = bus_end;
	den.r                 = !ads;
	sel_ic.clk            = clk;
	sel_ic.clrn           = clrn;
	sel_ic.r              = bus_end;
	sel_read_ic.clk       = clk;
	sel_read_ic.clrn      = clrn;
	sel_read_ic.r         = bus_end;
	sel_go.clk            = clk;
	sel_go.clrn           = clrn;
	sel_go.r              = bus_end;
	  
	sel_reset_singlea     = sel_reset_singlea_ff & wait_l;
	sel_reset_singlea_ff.clk  = clk;
	sel_reset_singlea_ff.clrn  = clrn;
	sel_reset_singlea_ff.r  = bus_end;
	  
	IF !ads THEN
		addr[]                = ad[31..0];
	ELSE
		addr[]                = addr[] + 32;
	END IF;
	addr[].clk            = clk;
	addr[].ena            = !ads  #  wait_l & !ready_i & !den;
	--============================================
	--=  Selectors to all memory address spaces  =
	--============================================
	go                    =  ad[0];
	  
	  
	sel_ports_d = sel_ports;
	 
	ready_i               = !sel_ic_lcell # !sel_ports_d & sel_read_ic & sel_ports # sel_reset_singlea_ff & !mem_ready;
	  
	 
	



	go.clk                = clk;
	go.clrn               = clrn;
	go.ena                = sel_go & lw_r;
	IF !ads & !ad[31] THEN
		IF (ad[24..24] == 0) THEN
			IF (ad[23..21] == (id2,id1,id0) ) THEN
				sel_ic.s = VCC;
				sel_read_ic.s = !lw_r;
	
				IF !ad[20] THEN
					sel_gmode.s=VCC;
					sel_go.s =  (ad[6..4] == H"2");
	
				ELSE
						-- SRAM / internal memories address space
					sel_reset_singlea_ff.s = VCC &lw_r;
				END IF;

			END IF;
		END IF;
	END IF;
  END;
