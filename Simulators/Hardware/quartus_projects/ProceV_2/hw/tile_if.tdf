

--------------------------------------------------------------------------------------
-- GiDEL Copyright © 1993-2013  
-- HDL tile_if is generated by GiDEL  ProcWizard Application  version 9.2.1.0
-- tile_if is the bus interface for ****  device (IC) 1 ****
-- This file was generated for PROC configuration file  :"C:\Users\Krishna\Desktop\Research\Ex_Emulator\ProceV_2\Emulator.pcaf".
-- This file may only be used for initialization and usage of GiDEL PROC boards.
-- Using this file, or any other related files, for any other purpose, is prohibited .
-- No other licenses are provided herein.

-- Created  Mon Feb 09 21:21:45 2015

-------------------------------------------------------------------------------------


INCLUDE	"g_avalon2if.inc";
INCLUDE	"tile_wrif.inc";
INCLUDE	"tile_rdif.inc";



		 CONSTANT GDREQ_WR_NUM          = 1;
		 CONSTANT GDREQ_RD_NUM          = 1;
		 CONSTANT CONSUMER_COUNT        = 32;


	SUBDESIGN   tile_if
	   (
		--============================================
		--=             Fixed connection             =
		--============================================
		ref_clk                    : INPUT;                    -- ref_clk
		clk0                       : OUTPUT;                   -- clk0
		clk                        : OUTPUT;                   -- clk
		clk2                       : OUTPUT;                   -- clk2
		mem_ref_clk_int            : OUTPUT;                   -- mem_ref_clk_int
		scl                        : BIDIR;                    -- scl
		sda                        : BIDIR;                    -- sda
		status_ledn[3..1]          : OUTPUT;                   -- status_ledn
		g_reserved[33..0]          : BIDIR;                    -- g_reserved
		clrn                       : OUTPUT;                   -- Reset input (active LOW)
		lclk                       : OUTPUT;                   -- Local clock
		user_dreq[31..0]           : INPUT;
		g_dreq_wr[GDREQ_WR_NUM-1..0]   : INPUT = GND;
		g_dreq_rd[GDREQ_RD_NUM-1..0]   : INPUT = GND;
		interrupt                  : INPUT;
		interrupt_ack              : OUTPUT;
		--============================================
		--=              Receiver I/O's              =
		--============================================
		g_reserved_control[99..0]   : OUTPUT;                  -- New for Star III
		id[2..0]                   : OUTPUT;                   -- New for Star III
		pcie_refclk                : INPUT;                    -- pcie_refclk
		pcie_perst                 : INPUT;                    -- pcie_perst
		pcie_rx[7..0]              : INPUT;                    -- pcie_rx
		pcie_tx[7..0]              : OUTPUT;                   -- pcie_tx
		--============================================
		--=               WR IF I/O's                =
		--============================================
		l_wr                       : OUTPUT;
		addr_wr[31..0]             : OUTPUT;
		addr_rd[31..0]             : OUTPUT;
		l_data_wr[255..0]          : OUTPUT;
		l_data_rd[255..0]          : INPUT = GND;
		l_rd                       : OUTPUT;
		mem_ready_wr               : INPUT = VCC;
		--============================================
		--=               RD IF I/O's                =
		--============================================
		mem_ready_rd               : INPUT = VCC;
		--============================================
		--=  Output from the logic to the host (status registers)  =
		--============================================
		done                       : INPUT;
		-- version of RBF
		rbf_version[7..0]          : INPUT;                    -- RBF_Info[7..0]
		almost_full_dst            : INPUT;                    -- status_dst[1]
		--============================================
		--=  Input from the host to the logic (mode registers)  =
		--============================================
		go                         : OUTPUT;
		--============================================
		--=  Selectors to all memory address spaces  =
		--============================================
		sel_reset_singlea          : OUTPUT;
		sel_singlea_dst            : OUTPUT;
	  )


VARIABLE
	 g_pcielb2if_cmp            : g_avalon2if WITH (CONSUMER_COUNT = CONSUMER_COUNT , USER_ITRP_NUM  = 1,
		 GDREQ_WR_NUM = GDREQ_WR_NUM,GDREQ_RD_NUM = GDREQ_RD_NUM, LBUS_FREQUENCY	= 100);
	 tile_ifw                   : tile_wrif;
	 tile_ifr                   : tile_rdif;




BEGIN

	g_reserved_control[]  = g_pcielb2if_cmp.g_reserved_control[];
	tile_ifw.id0          = g_pcielb2if_cmp.id0;
	tile_ifr.id0          = g_pcielb2if_cmp.id0;
	id[0]                 = g_pcielb2if_cmp.id0;
	tile_ifw.id1          = g_pcielb2if_cmp.id1;
	tile_ifr.id1          = g_pcielb2if_cmp.id1;
	id[1]                 = g_pcielb2if_cmp.id1;
	tile_ifw.id2          = g_pcielb2if_cmp.id2;
	tile_ifr.id2          = g_pcielb2if_cmp.id2;
	id[2]                 = g_pcielb2if_cmp.id2;
	g_pcielb2if_cmp.ref_clk  = ref_clk;
	clk0                  = g_pcielb2if_cmp.clk0;
	clk                   = g_pcielb2if_cmp.clk;
	clk2                  = g_pcielb2if_cmp.clk2;
	mem_ref_clk_int       = g_pcielb2if_cmp.mem_ref_clk_int;
	clrn                  = g_pcielb2if_cmp.clrn;
	scl                   = g_pcielb2if_cmp.scl;
	sda                   = g_pcielb2if_cmp.sda;
	status_ledn[]         = g_pcielb2if_cmp.status_ledn[];
	g_reserved[]          = g_pcielb2if_cmp.g_reserved[];
	g_pcielb2if_cmp.pcie_refclk  = pcie_refclk;
	g_pcielb2if_cmp.pcie_perst  = pcie_perst;
	g_pcielb2if_cmp.pcie_rx[]  = pcie_rx[];
	pcie_tx[]             = g_pcielb2if_cmp.pcie_tx[];
	g_pcielb2if_cmp.g_dreq_rd[]  = (0,g_dreq_rd[]);
	g_pcielb2if_cmp.user_dreq[CONSUMER_COUNT-1..0]  = user_dreq[CONSUMER_COUNT-1..0];
	g_pcielb2if_cmp.interrupt[]  = interrupt;
	interrupt_ack         = g_pcielb2if_cmp.interrupt_ack[0..0];
	g_pcielb2if_cmp.ready_w  = tile_ifw.ready;
	g_pcielb2if_cmp.ready_r  = tile_ifr.ready;
	g_pcielb2if_cmp.ad_i_r[]  = tile_ifr.ad_o[];
	tile_ifw.clk          = g_pcielb2if_cmp.clk_w;
	tile_ifw.clrn         = clrn;
	tile_ifw.ads          = g_pcielb2if_cmp.ads_w;
	tile_ifw.ad_i[]       = g_pcielb2if_cmp.ad_o_w[];
	tile_ifw.lw_r_i       = g_pcielb2if_cmp.lw_r_w;
	tile_ifw.blast        = g_pcielb2if_cmp.blast_w;
	tile_ifw.wait_l       = g_pcielb2if_cmp.wait_l_w;
	lclk                  = g_pcielb2if_cmp.clk_w;
	l_wr                  = tile_ifw.lw_r;
	addr_wr[]             = tile_ifw.addr[];
	l_data_wr[]           = tile_ifw.ad[];
	tile_ifw.mem_ready    = mem_ready_wr;
	tile_ifr.clk          = g_pcielb2if_cmp.clk_r;
	tile_ifr.clrn         = clrn;
	tile_ifr.ads          = g_pcielb2if_cmp.ads_r;
	tile_ifr.ad_i[]       = g_pcielb2if_cmp.ad_o_r[];
	tile_ifr.lw_r_i       = g_pcielb2if_cmp.lw_r_r;
	tile_ifr.blast        = g_pcielb2if_cmp.blast_r;
	tile_ifr.wait_l       = g_pcielb2if_cmp.wait_l_r;
	l_rd                  = tile_ifr.lw_r;
	addr_rd[]             = tile_ifr.addr[];
	tile_ifr.mem_data[]   = l_data_rd[];
	tile_ifr.mem_ready    = mem_ready_rd;
	--============================================
	--=           Variable connection            =
	--============================================
	tile_ifr.done                        =  done;
	tile_ifr.rbf_version[]               =  rbf_version[];
	tile_ifr.almost_full_dst             =  almost_full_dst;
	go                                   =  tile_ifw.go;
	sel_reset_singlea                    =  tile_ifw.sel_reset_singlea;
	sel_singlea_dst                      =  tile_ifr.sel_singlea_dst;
  END;
